#summary Creating custom streamers.

= Creating custom streamers =

If you need to add serialization of custom type that does not implement `Streamable` interface you may define your own streamer class.
{{{
public class MyCustomStreamer extends Streamer {
    @Override
    public void writeObject( Object obj, WriteContext ctx, Writer out ) {
        // save object identity to avoid reference duplication within the same graph
        ctx.addRef( obj );
        // write object fields
        MyObject mo = (Object) obj;
        out.writeInt( mo.intField );
        out.writeString( mo.stringField );
        get().writeObject( mo.objectField, ctx, out );
    }

    @Override
    public Object readObject( ReadContext ctx, Reader in )
    {
        // create object
        MyObject mo = ...
        // add identity to restore serialized references properly
        ctx.addRef( mo );
        // reading fields
        mo.intField = in.readInt();
        mo.stringField = in.readString();
        mo.objectField = get().readObject( ctx, in );
        return mo;
    }
}
}}}

Create class that extends `Streamer` and redefine `readObject()` and `writeObject()` methods to serialize object in your own manner.

You may also extend one of predefined streamers:
  * `ArrayStreamer` for arrays
  * `CollectionStreamer` for collections
  * `EnumStreamer` for custom enums
  * `MapStreamer` for maps
  * `StructStreamer` for field-based objects

To use new streamer you must register it somewhere in the initialization part of the application:
{{{
...
Streamer.registerStreamer( MyObject.class, new MyCustomStreamer() );
...
}}}
Note! You must also register the same serializer at server side.