#summary Using Streamer at server side.

= Using Streamer at server side =

A `Streamer.get()` method uses lazy initialization of type streamers which is not thread-safe and sometimes may cause concurrent problems in a multithreaded server environment. To avoid this the library must be initialized during server bootstrap by calling `Streamer.get()`. There are several ways to do this:
  * If you write your own servlet simply add `Streamer.get()` to servlet constructor or initialization part.
  * If you use third-party servlet you may register a servlet listener that calls `Streamer.get()` during an application startup.
`web.xml`
{{{
<web-app>
   ...
   <listener>
      <listener-class>com.acme.GWTStreamerInitializer</listenerclass>
   </listener>
   ...
</web-app>
}}}
`GWTStreamerInitializer.java`
{{{
public class GWTStreamerInitializer implements ServletContextListener {
    @Override    
    public void contextInitialized(ServletContextEvent sce) {
        Streamer.get();
    }
}
}}}
  * In IoC container like Spring use an instance of `Streamer` created by `StreamerFactory` class. First register `com.nkdata.gwt.streamer.server.StreamerFactory` class as singleton factory for `Streamer` class.
`applicationContext.xml`
{{{
...
<bean id="streamerFactory" class="com.nkdata.gwt.streamer.server.StreamerFactory"/>
<bean id="streamer" factory-bean="streamerFactory" factory-method="getInstance"/>
...
}}}
Then use injection of `Streamer` instance instead of static call to `Streamer.get()`.
{{{
@Inject
private Streamer streamer;
...
MyObject myObject = ...
String buf = streamer.toString( myObject );
...
}}}
  * Guice can map interface directly to singleton instance:
Sample Guice configuration:
{{{
...
bind(Streamer.class).toInstance(Streamer.get());
...
}}}